## P3416 [USACO16DEC] Moocast S

https://usaco.org/index.php?page=viewproblem2&cpid=668

约翰农场主的 $N$ 头奶牛需要建立一个广播系统，每头奶牛有一个对讲机，具有一定的传输半径 $P$。一头奶牛可以通过直接或中继的方式，将信息传递给其他奶牛。目标是找到从某头奶牛开始广播时，能够到达的奶牛的最大数量。

### 算法分析

1. **图的构建**：
   - 每头奶牛看作一个节点。
   - 如果奶牛 $i$ 的对讲机能直接覆盖奶牛 $j$，则在图中从 $i$ 到 $j$ 添加一条有向边。

2. **广度优先搜索 (BFS)**：
   - 从每个节点开始，使用 BFS 遍历可达的所有节点。
   - 记录从某个节点开始可以到达的最大节点数。

### 代码注释

```python
# 读取奶牛数量
n = int(input())

# 初始化邻接表，用于存储每头奶牛可以直接发送信息到达的奶牛
e = [[] for _ in range(n)]

# 初始化位置和能量列表
pos, p = [], []

# 读取每头奶牛的位置和能量
for _ in range(n):
    x1, y1, p1 = map(int, input().split())
    pos.append((x1, y1))
    p.append(p1)

# 计算两头奶牛之间的距离平方
def dis(a, b):
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2

# 构建图，确定每头奶牛可以直接向哪些奶牛发送信息
for i in range(n): 
    for j in range(n):
        if i == j: continue  # 跳过自己
        # 如果奶牛 j 在奶牛 i 的传输范围内，则添加到邻接表
        if dis(pos[i], pos[j]) <= p[i] ** 2:
            e[i].append(j)

from collections import deque

# 初始化最大可到达奶牛数量
ans = 0

# 对每头奶牛执行广度优先搜索（BFS）
for i in range(n):
    # 用于记录访问过的奶牛
    vis = [False] * n
    # 创建队列进行 BFS
    q = deque()
    q.append(i)
    tot = 0
    vis[i] = True
    while len(q) > 0:
        tot += 1
        u = q.popleft()
        # 遍历当前奶牛可以直接到达的奶牛
        for v in e[u]:
            if not vis[v]:  # 如果奶牛 v 未访问过
                q.append(v)
                vis[v] = True
    # 更新最大可到达奶牛数量
    if tot > ans:
        ans = tot

# 输出最大可到达奶牛数量
print(ans)
```

## 程序填空版

```python
n = int(input())
e = [[] for _ in range(n)]
pos, p = [], []

for _ in range(n):
    x1, y1, p1 = map(int, input().split())
    pos.append((x1, y1))
    p.append(p1)

def dis(a, b):
    # 计算两头奶牛之间的距离平方
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2

for i in range(n): 
    for j in range(n):
        if i == j: continue
        # 如果奶牛 j 在奶牛 i 的传输范围内，则添加到邻接表
        if dis(pos[i], pos[j]) <= ________:
            e[i].append(j)

from collections import ________
ans = 0

for i in range(n):
    # 用于记录访问过的奶牛
    vis = [False] * n
    # 创建队列进行 BFS
    q = deque()
    q.append(i)
    tot = 0
    vis[i] = ________
    
    while len(q) > 0:
        tot += 1
        u = q.________()
        # 遍历当前奶牛可以直接到达的奶牛
        for v in e[u]:
            if not vis[v]:
                q.append(v)
                vis[v] = ________
    
    # 更新最大可到达奶牛数量
    if tot > ans:
        ans = tot

# 输出最大可到达奶牛数量
print(______)
```

该算法使用图的表示和 BFS 来计算每头奶牛作为起点时，最多可以到达多少头奶牛。通过遍历每个节点并执行 BFS，我们可以找到最大的可达节点数。复杂度主要受 BFS 和图的构建影响，为 $O(N^2)$。

## P6111 [USACO18JAN] MooTube S


