## # P5194 [USACO05DEC] Scales S

这道题是一道搜索题，一种思路是直接对每一个数做出选与不选的判断，时间复杂度 O(2n)O(2n) 。在这种时间复杂度下，只能通过 n≤30n≤30 的数据。

如何进行优化呢？

1. 改变搜索顺序。这一道题的输入数据是一个不下降序列，如果我们把小的数放在前面，而 CC 又比较大的话，前面的小数就会有很多的空间进行选择，极限数据下甚至可以卡死代码。为了避免这种情况，我在读入的时候从 anan​ 开始倒着读，这样 a 数组中就是一个不上升子序列，前面的大数很容易就因为 CC 的限制失去很多选择，节省了很多的时间。其中 a 数组是我存放数的数组。
2. 模拟可行性剪枝，我们不妨这么想：如果说**当前所选的数的总和**加上**后面的数的总和，即后缀和**都没有超过 CC 的话，那么当前的和就是在这种选择下可以达到的最大值。既然我们已经知道了最大值，并且题目所求的就是最大值，此时我们可以直接去更新答案， 然后退出这一层搜索。面对数很多的时候，这个剪枝会发挥出极大的威力。

```py
from collections import deque
n, c = map(int, input().split())
a = []
for _ in range(n):
    a.append(int(input()))
a.sort(reverse=True)

suf = [0] * (n + 1)
for i in range(n - 1, -1, -1):
    suf[i] = suf[i + 1] + a[i]
ans = 0
def dfs(pos, t):
    global ans
    if t > c:
        return
    if suf[pos] + t <= c:
        ans = max(suf[pos] + t, ans)
        return
    ans = max(ans, t)
    for i in range(pos, n):
        dfs(i + 1, t + a[i])
dfs(0, 0)
print(ans)

```

## P2997 [USACO10NOV] Banner S

https://www.luogu.com.cn/problem/P2997

```
平面上有(0,0)到(n,m)的(n+1)*(m+1)个点。问有多少点对所连的线段不过其他点，且长度在[l,h]范围内
```

枚举 dx, dy, dx 与 dy 互质即可。

```py
def gcd(a: int, b: int):
    return b if a % b == 0 else gcd(b, a % b)

n, m, l, r = map(int, input().split())
answer = 0
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if gcd(i, j) == 1 and l * l <= i * i + j * j <= r * r:
            answer += 2 * (n - i + 1) * (m - j + 1)
if l == 1:
    answer += n * (m + 1) + (n + 1) * m
print(answer)
```
