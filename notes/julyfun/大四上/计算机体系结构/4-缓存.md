---
title: 4-缓存
date: 2024-12-08 21:23:11
tags: ["notes", "julyfun", "大四上", "计算机体系结构"]
---
> mostly gpt-4o

### 写策略（Write Policies）

1. **写回（Write-back）**： 保证仅直接操作缓存
   - 缓存中映射了内存的某一些地址。如果写时目标地址在缓存中，则称为“写命中”，此时可以先写入缓存，暂时不写入内存. 之后会刷入内存.
   - 当发生写命中时，数据只写入缓存，而不立即写入主存。
   - 写入缓存后，标记为“脏”的位会被设置为1，表示该块数据已被修改但尚未写入主存。
   - 写入缓存的速度很快，因此写回缓存的写延迟通常很小。
   - 当一个块从写回缓存中被驱逐时，如果其“脏”位为1，则必须将该块的数据写入主存。这增加了硬件实现的复杂性。

2. **直写（Write-through）**： 保证操作主存
   - 当发生写命中时，数据同时写入缓存和主存。
   - 写入缓存的速度很快，但写入主存的速度较慢，因此直写缓存的写延迟比写回缓存的要慢。
   - 直写缓存使硬件设计更简单，因为可以假设主存中的数据始终是最新的。

3. **写绕过（Write-around）**：什么玩意儿
   - 在任何情况下，数据都直接写入主存。
   - 如果写入的数据块在缓存中存在，则将其有效位设置为无效。
   - 本质上，写绕过缓存中不存在写命中，写“命中”与写未命中执行相同的操作。

### 未命中策略（Miss Policies）

1. **写分配（Write-allocate）**：保证仅直接操作缓存
   - 当发生写未命中时，将未命中的块加载到缓存中。
   - 针对写回、写分配缓存，这意味着数据不会直接写入主存，而是先写入缓存，随后在块被驱逐时再更新主存。
2. **无写分配（Write-No-Allocate）**：保证操作主存
   - 未命中时，数据直接写入主存，而不将数据加载到缓存中。这种策略适用于写操作较少的情况，因为它避免了不必要的缓存替换。

### 缓存替换策略

1. **LRU（Least Recently Used，最近最少使用）**：
    
    - 当需要驱逐一个缓存块时，选择那个最久未被使用的块。
    - 这种策略假设最近使用的数据块在未来也可能会被再次使用，因此优先保留最近使用的块。
    - 实现LRU策略需要跟踪每个块的使用时间，这可能需要额外的硬件或软件开销。
2. **Random（随机替换）**：
    
    - 当需要驱逐一个缓存块时，随机选择一个块进行驱逐。
    - 这种策略实现简单，不需要跟踪缓存块的使用历史。
    - 虽然随机替换策略在某些情况下可能不如LRU等策略高效，但在实现复杂度和性能之间提供了一个平衡点。

### N 路

N-Way Set Associative（N路组相联）是一种缓存放置策略，它结合了直接映射和全相联缓存的优点。缓存被分成若干组（sets），每组包含多个缓存块（ways）。内存地址首先映射到一个特定的组，然后可以放置在该组内的任何一个块中。

#### 具体参数解释

1. **Associativity (相联度)**:
    - 在这张图片中，相联度设置为4，这意味着缓存是4路组相联。
    - 这表示每个组内有 N = 4 个缓存块。
2. **Cache Size (缓存大小)**:
    - 缓存总大小为256字节。
3. **Block Size (块大小)**:
    - 假设块大小为16字节。
#### 计算组数

缓存的总大小为256字节，相联度为4，块大小为16字节：

- 每组的大小 = 相联度 × 块大小 = 4 × 16 = 64字节
- 组数 = 缓存总大小 / 每组大小 = 256 / 64 = 4组

#### 工作原理

1. **地址映射**:
    
    - 内存地址通过索引部分映射到特定的组，索引的计算方式是：`(内存地址 / 块大小) % 组数`
    - 例如，对于一个地址`0x00`，块大小为16字节，组数为4：
        - 组索引 = `(0x00 / 16) % 4 = 0`
    - 地址`0x10`：
        - 组索引 = `(0x10 / 16) % 4 = 1`

## L1 & L2

- ![image.png|500](https://how-to-1258460161.cos.ap-shanghai.myqcloud.com/how-to/20241208205121.webp)
- 就是说 L1 没访问到，才去访问 L2.
