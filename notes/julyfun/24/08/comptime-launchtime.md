---
title: comptime? runtime? launchtime!
date: 2024-09-25 16:58:43
tags: []
---
# comptime? runtime? launchtime!

考虑参数的修改和加载：

| time                             | 例子                 | 修改数值代价    | 修改参数名代价  | 运行代价                               |
| -------------------------------- | -------------------- | --------------- | --------------- | -------------------------------------- |
| comptime 编译时常量              | constexpr            | 重新编译 + 运行 | 重新编译 + 运行 | 无                                     |
| launch time / init time 参数文件 | ros2 param yaml file | 重新运行        | 重新编译 + 运行 | 启动时几毫秒                           |
| runtime 热加载                   | ros2 param set       | 无              | 重新编译 + 运行 | 启动时几毫秒，每次查询几十纳秒到几微秒 |

参数表如果是一个 string => value 的 map，那么查询较长的名字比较耗费时间和空间。这其实可以在 comptime 进行优化，然而 C++ / Rust 怎么实现呢？btw，宏可以实现这个编译时的抽象，但是很难保证热加载灵活性。Zig 应该很好实现编译时字符串压缩。

如果做一个跨平台 GUI，肯定要做抽象层。如果采用的是 Box<dyn Trait> 或者抽象类这种方案，就是 runtime 抽象，必然有一定性能损失。然而这些抽象如果在 comptime 做，应该可以让损失非常小，编译结束时即可消除抽象，近乎直接生成平台原生代码。

元编程可以做到以上所有事情，它本身就是 comptime 的抽象，然而基于 AST 的元编程太过底层，lsp 难以发挥作用，开发和维护成本都很高。也许 Zig 能代替元编程轻松做到代码生成，有空玩玩。

> 每次想到这个就为 Rust 的 comptime 能力感到遗憾。
